<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://saebekassebil.github.com/teoria"

    >teoria (v2.2.2)</a>
</h1>
<h4>Music theory for JavaScript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria">module teoria</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord">
            function <span class="apidocSignatureSpan">teoria.</span>Chord
            <span class="apidocSignatureSpan">(root, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval">
            function <span class="apidocSignatureSpan">teoria.</span>Interval
            <span class="apidocSignatureSpan">(coord)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note">
            function <span class="apidocSignatureSpan">teoria.</span>Note
            <span class="apidocSignatureSpan">(coord, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale">
            function <span class="apidocSignatureSpan">teoria.</span>Scale
            <span class="apidocSignatureSpan">(tonic, scale)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.chord">
            function <span class="apidocSignatureSpan">teoria.</span>chord
            <span class="apidocSignatureSpan">(name, symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.interval">
            function <span class="apidocSignatureSpan">teoria.</span>interval
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.note">
            function <span class="apidocSignatureSpan">teoria.</span>note
            <span class="apidocSignatureSpan">(name, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.scale">
            function <span class="apidocSignatureSpan">teoria.</span>scale
            <span class="apidocSignatureSpan">(tonic, scale)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">teoria.</span>Chord.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">teoria.</span>Interval.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">teoria.</span>Note.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">teoria.</span>Scale.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">teoria.</span>vector</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Chord">module teoria.Chord</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.Chord">
            function <span class="apidocSignatureSpan">teoria.</span>Chord
            <span class="apidocSignatureSpan">(root, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Chord.prototype">module teoria.Chord.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.bass">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>bass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.chordType">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>chordType
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.dominant">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>dominant
            <span class="apidocSignatureSpan">(additional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.get">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>get
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.interval">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>interval
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.notes">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>notes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.parallel">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>parallel
            <span class="apidocSignatureSpan">(additional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.quality">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>quality
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.resetVoicing">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>resetVoicing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.simple">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>simple
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.subdominant">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>subdominant
            <span class="apidocSignatureSpan">(additional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.toString">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.transpose">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>transpose
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Chord.prototype.voicing">
            function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>voicing
            <span class="apidocSignatureSpan">(voicing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Interval">module teoria.Interval</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.Interval">
            function <span class="apidocSignatureSpan">teoria.</span>Interval
            <span class="apidocSignatureSpan">(coord)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.between">
            function <span class="apidocSignatureSpan">teoria.Interval.</span>between
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.from">
            function <span class="apidocSignatureSpan">teoria.Interval.</span>from
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.invert">
            function <span class="apidocSignatureSpan">teoria.Interval.</span>invert
            <span class="apidocSignatureSpan">(sInterval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.toCoord">
            function <span class="apidocSignatureSpan">teoria.Interval.</span>toCoord
            <span class="apidocSignatureSpan">(simple)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Interval.prototype">module teoria.Interval.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.add">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>add
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.base">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>base
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.direction">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>direction
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.equal">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>equal
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.greater">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>greater
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.invert">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.isCompound">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>isCompound
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.name">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.number">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>number
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.octaves">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>octaves
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.quality">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>quality
            <span class="apidocSignatureSpan">(lng)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.qualityValue">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>qualityValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.semitones">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>semitones
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.simple">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>simple
            <span class="apidocSignatureSpan">(ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.smaller">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>smaller
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.toString">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>toString
            <span class="apidocSignatureSpan">(ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.type">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Interval.prototype.value">
            function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Note">module teoria.Note</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.Note">
            function <span class="apidocSignatureSpan">teoria.</span>Note
            <span class="apidocSignatureSpan">(coord, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.fromFrequency">
            function <span class="apidocSignatureSpan">teoria.Note.</span>fromFrequency
            <span class="apidocSignatureSpan">(fq, concertPitch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.fromKey">
            function <span class="apidocSignatureSpan">teoria.Note.</span>fromKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.fromMIDI">
            function <span class="apidocSignatureSpan">teoria.Note.</span>fromMIDI
            <span class="apidocSignatureSpan">(note)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.fromString">
            function <span class="apidocSignatureSpan">teoria.Note.</span>fromString
            <span class="apidocSignatureSpan">(name, dur)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Note.prototype">module teoria.Note.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.accidental">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>accidental
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.accidentalValue">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>accidentalValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.chord">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>chord
            <span class="apidocSignatureSpan">(chord)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.chroma">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>chroma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.durationInSeconds">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>durationInSeconds
            <span class="apidocSignatureSpan">(bpm, beatUnit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.durationName">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>durationName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.enharmonics">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>enharmonics
            <span class="apidocSignatureSpan">(oneaccidental)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.fq">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>fq
            <span class="apidocSignatureSpan">(concertPitch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.helmholtz">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>helmholtz
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.interval">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>interval
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.key">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>key
            <span class="apidocSignatureSpan">(white)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.midi">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>midi
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.name">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.octave">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>octave
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.scale">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>scale
            <span class="apidocSignatureSpan">(scale)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.scaleDegree">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>scaleDegree
            <span class="apidocSignatureSpan">(scale)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.scientific">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>scientific
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.solfege">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>solfege
            <span class="apidocSignatureSpan">(scale, showOctaves)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.toString">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>toString
            <span class="apidocSignatureSpan">(dont)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Note.prototype.transpose">
            function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>transpose
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Scale">module teoria.Scale</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.Scale">
            function <span class="apidocSignatureSpan">teoria.</span>Scale
            <span class="apidocSignatureSpan">(tonic, scale)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">teoria.Scale.</span>KNOWN_SCALES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.Scale.prototype">module teoria.Scale.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.get">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>get
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.interval">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>interval
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.notes">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>notes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.simple">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>simple
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.solfege">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>solfege
            <span class="apidocSignatureSpan">(index, showOctaves)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.transpose">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>transpose
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.Scale.prototype.type">
            function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.interval">module teoria.interval</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.interval.interval">
            function <span class="apidocSignatureSpan">teoria.</span>interval
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.interval.between">
            function <span class="apidocSignatureSpan">teoria.interval.</span>between
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.interval.from">
            function <span class="apidocSignatureSpan">teoria.interval.</span>from
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.interval.invert">
            function <span class="apidocSignatureSpan">teoria.interval.</span>invert
            <span class="apidocSignatureSpan">(sInterval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.interval.toCoord">
            function <span class="apidocSignatureSpan">teoria.interval.</span>toCoord
            <span class="apidocSignatureSpan">(simple)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.note">module teoria.note</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.note.note">
            function <span class="apidocSignatureSpan">teoria.</span>note
            <span class="apidocSignatureSpan">(name, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.note.fromFrequency">
            function <span class="apidocSignatureSpan">teoria.note.</span>fromFrequency
            <span class="apidocSignatureSpan">(fq, concertPitch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.note.fromKey">
            function <span class="apidocSignatureSpan">teoria.note.</span>fromKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.note.fromMIDI">
            function <span class="apidocSignatureSpan">teoria.note.</span>fromMIDI
            <span class="apidocSignatureSpan">(note)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.note.fromString">
            function <span class="apidocSignatureSpan">teoria.note.</span>fromString
            <span class="apidocSignatureSpan">(name, dur)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.teoria.vector">module teoria.vector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.vector.add">
            function <span class="apidocSignatureSpan">teoria.vector.</span>add
            <span class="apidocSignatureSpan">(note, interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.vector.mul">
            function <span class="apidocSignatureSpan">teoria.vector.</span>mul
            <span class="apidocSignatureSpan">(note, interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.vector.sub">
            function <span class="apidocSignatureSpan">teoria.vector.</span>sub
            <span class="apidocSignatureSpan">(note, interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.teoria.vector.sum">
            function <span class="apidocSignatureSpan">teoria.vector.</span>sum
            <span class="apidocSignatureSpan">(coord)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria" id="apidoc.module.teoria">module teoria</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Chord" id="apidoc.element.teoria.Chord">
        function <span class="apidocSignatureSpan">teoria.</span>Chord
        <span class="apidocSignatureSpan">(root, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chord(root, name) {
  if (!(this instanceof Chord)) return new Chord(root, name);
  name = name || &#x27;&#x27;;
  this.name = root.name().toUpperCase() + root.accidental() + name;
  this.symbol = name;
  this.root = root;
  this.intervals = [];
  this._voicing = [];

  var bass = name.split(&#x27;/&#x27;);
  if (bass.length === 2 &#x26;&#x26; bass[1].trim() !== &#x27;9&#x27;) {
    name = bass[0];
    bass = bass[1].trim();
  } else {
    bass = null;
  }

  this.intervals = daccord(name).map(Interval.toCoord);
  this._voicing = this.intervals.slice();

  if (bass) {
    var intervals = this.intervals, bassInterval, note;
    // Make sure the bass is atop of the root note
    note = Note.fromString(bass + (root.octave() + 1)); // crude

    bassInterval = Interval.between(root, note);
    bass = bassInterval.simple();
    bassInterval = bassInterval.invert().direction(&#x27;down&#x27;);

    this._voicing = [bassInterval];
    for (var i = 0, length = intervals.length;  i &#x3c; length; i++) {
      if (!intervals[i].simple().equal(bass))
        this._voicing.push(intervals[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval" id="apidoc.element.teoria.Interval">
        function <span class="apidocSignatureSpan">teoria.</span>Interval
        <span class="apidocSignatureSpan">(coord)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Interval(coord) {
  if (!(this instanceof Interval)) return new Interval(coord);
  this.coord = coord;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note" id="apidoc.element.teoria.Note">
        function <span class="apidocSignatureSpan">teoria.</span>Note
        <span class="apidocSignatureSpan">(coord, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Note(coord, duration) {
  if (!(this instanceof Note)) return new Note(coord, duration);
  duration = duration || {};

  this.duration = { value: duration.value || 4, dots: duration.dots || 0 };
  this.coord = coord;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale" id="apidoc.element.teoria.Scale">
        function <span class="apidocSignatureSpan">teoria.</span>Scale
        <span class="apidocSignatureSpan">(tonic, scale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scale(tonic, scale) {
  if (!(this instanceof Scale)) return new Scale(tonic, scale);
  var scaleName, i;
  if (!(&#x27;coord&#x27; in tonic)) {
    throw new Error(&#x27;Invalid Tonic&#x27;);
  }

  if (typeof scale === &#x27;string&#x27;) {
    scaleName = scale;
    scale = scales[scale];
    if (!scale)
      throw new Error(&#x27;Invalid Scale&#x27;);
  } else {
    for (i in scales) {
      if (scales.hasOwnProperty(i)) {
        if (scales[i].toString() === scale.toString()) {
          scaleName = i;
          break;
        }
      }
    }
  }

  this.name = scaleName;
  this.tonic = tonic;
  this.scale = scale;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.chord" id="apidoc.element.teoria.chord">
        function <span class="apidocSignatureSpan">teoria.</span>chord
        <span class="apidocSignatureSpan">(name, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chordConstructor(name, symbol) {
  if (typeof name === &#x27;string&#x27;) {
    var root, octave;
    root = name.match(/^([a-h])(x|#|bb|b?)/i);
    if (root &#x26;&#x26; root[0]) {
      octave = typeof symbol === &#x27;number&#x27; ? symbol.toString(10) : &#x27;4&#x27;;
      return new Chord(Note.fromString(root[0].toLowerCase() + octave),
                            name.substr(root[0].length));
    }
  } else if (name instanceof Note)
    return new Chord(name, symbol);

  throw new Error(&#x27;Invalid Chord. Couldn\&#x27;t find note name&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.<span class="apidocCodeKeywordSpan">chord</span>(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27
;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
teoria.chord(&#x27;Ab#5b9&#x27;);   // Returns a Chord object, representing a Ab#5b9 chord
g5.chord(&#x27;dim&#x27;);          // Returns a Chord object, representing a Gdim chord

// Calculate note frequencies or find the note corresponding to a frequency
teoria.note.fromFrequency(467); // Returns: {&#x27;note&#x27;:{...},&#x27;cents&#x27;:3.102831} -&#x3e; A4# a little out of tune
.
a4.fq(); // Outputs 440
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.interval" id="apidoc.element.teoria.interval">
        function <span class="apidocSignatureSpan">teoria.</span>interval
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intervalConstructor(from, to) {
  // Construct a Interval object from string representation
  if (typeof from === &#x27;string&#x27;)
    return Interval.toCoord(from);

  if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
    return Interval.from(from, Interval.toCoord(to));

  if (to instanceof Interval &#x26;&#x26; from instanceof Note)
    return Interval.from(from, to);

  if (to instanceof Note &#x26;&#x26; from instanceof Note)
    return Interval.between(from, to);

  throw new Error(&#x27;Invalid parameters&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.<span class="apidocCodeKeywordSpan">interval</span>(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.note" id="apidoc.element.teoria.note">
        function <span class="apidocSignatureSpan">teoria.</span>note
        <span class="apidocSignatureSpan">(name, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noteConstructor(name, duration) {
  if (typeof name === &#x27;string&#x27;)
    return Note.fromString(name, duration);
  else
    return new Note(name, duration);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (name instanceof Note)
  return new Chord(name, symbol);

throw new Error(&#x27;Invalid Chord. Couldn\&#x27;t find note name&#x27;);
}

function scaleConstructor(tonic, scale) {
tonic = (tonic instanceof Note) ? tonic : teoria.<span class="apidocCodeKeywordSpan">note</span>(tonic);
return new Scale(tonic, scale);
}

teoria = {
note: noteConstructor,

chord: chordConstructor,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.scale" id="apidoc.element.teoria.scale">
        function <span class="apidocSignatureSpan">teoria.</span>scale
        <span class="apidocSignatureSpan">(tonic, scale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scaleConstructor(tonic, scale) {
  tonic = (tonic instanceof Note) ? tonic : teoria.note(tonic);
  return new Scale(tonic, scale);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.<span class="apidocCodeKeywordSpan">scale</span>(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#
x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Chord" id="apidoc.module.teoria.Chord">module teoria.Chord</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Chord.Chord" id="apidoc.element.teoria.Chord.Chord">
        function <span class="apidocSignatureSpan">teoria.</span>Chord
        <span class="apidocSignatureSpan">(root, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chord(root, name) {
  if (!(this instanceof Chord)) return new Chord(root, name);
  name = name || &#x27;&#x27;;
  this.name = root.name().toUpperCase() + root.accidental() + name;
  this.symbol = name;
  this.root = root;
  this.intervals = [];
  this._voicing = [];

  var bass = name.split(&#x27;/&#x27;);
  if (bass.length === 2 &#x26;&#x26; bass[1].trim() !== &#x27;9&#x27;) {
    name = bass[0];
    bass = bass[1].trim();
  } else {
    bass = null;
  }

  this.intervals = daccord(name).map(Interval.toCoord);
  this._voicing = this.intervals.slice();

  if (bass) {
    var intervals = this.intervals, bassInterval, note;
    // Make sure the bass is atop of the root note
    note = Note.fromString(bass + (root.octave() + 1)); // crude

    bassInterval = Interval.between(root, note);
    bass = bassInterval.simple();
    bassInterval = bassInterval.invert().direction(&#x27;down&#x27;);

    this._voicing = [bassInterval];
    for (var i = 0, length = intervals.length;  i &#x3c; length; i++) {
      if (!intervals[i].simple().equal(bass))
        this._voicing.push(intervals[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Chord.prototype" id="apidoc.module.teoria.Chord.prototype">module teoria.Chord.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.bass" id="apidoc.element.teoria.Chord.prototype.bass">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>bass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bass = function () {
  return this.root.interval(this._voicing[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.chordType" id="apidoc.element.teoria.Chord.prototype.chordType">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>chordType
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chordType = function () { // In need of better name
  var length = this.intervals.length, interval, has, invert, i, name;

  if (length === 2) {
    return &#x27;dyad&#x27;;
  } else if (length === 3) {
    has = {first: false, third: false, fifth: false};
    for (i = 0; i &#x3c; length; i++) {
      interval = this.intervals[i];
      invert = interval.invert();
      if (interval.base() in has) {
        has[interval.base()] = true;
      } else if (invert.base() in has) {
        has[invert.base()] = true;
      }
    }

    name = (has.first &#x26;&#x26; has.third &#x26;&#x26; has.fifth) ? &#x27;triad&#x27; : &#x27;trichord&#x27;;
  } else if (length === 4) {
    has = {first: false, third: false, fifth: false, seventh: false};
    for (i = 0; i &#x3c; length; i++) {
      interval = this.intervals[i];
      invert = interval.invert();
      if (interval.base() in has) {
        has[interval.base()] = true;
      } else if (invert.base() in has) {
        has[invert.base()] = true;
      }
    }

    if (has.first &#x26;&#x26; has.third &#x26;&#x26; has.fifth &#x26;&#x26; has.seventh) {
      name = &#x27;tetrad&#x27;;
    }
  }

  return name || &#x27;unknown&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return new Chord(this.root.interval(&#x27;P4&#x27;), additional);
  },

  parallel: function(additional) {
additional = additional || &#x27;&#x27;;
var quality = this.quality();

if (this.<span class="apidocCodeKeywordSpan">chordType</span>() !== &#x27;triad&#x27; || quality === &#x27;diminished&#x27; ||
    quality === &#x27;augmented&#x27;) {
  throw new Error(&#x27;Only major/minor triads have parallel chords&#x27;);
}

if (quality === &#x27;major&#x27;) {
  return new Chord(this.root.interval(&#x27;m3&#x27;, &#x27;down&#x27;), &#x27;m&#x27;);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.dominant" id="apidoc.element.teoria.Chord.prototype.dominant">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>dominant
        <span class="apidocSignatureSpan">(additional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dominant = function (additional) {
  additional = additional || &#x27;&#x27;;
  return new Chord(this.root.interval(&#x27;P5&#x27;), additional);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.get" id="apidoc.element.teoria.Chord.prototype.get">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>get
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (interval) {
  if (typeof interval === &#x27;string&#x27; &#x26;&#x26; interval in knowledge.stepNumber) {
    var intervals = this.intervals, i, length;

    interval = knowledge.stepNumber[interval];
    for (i = 0, length = intervals.length; i &#x3c; length; i++) {
      if (intervals[i].number() === interval) {
        return this.root.interval(intervals[i]);
      }
    }

    return null;
  } else {
    throw new Error(&#x27;Invalid interval name&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a4.fq(); // Outputs 440
g5.fq(); // Outputs 783.9908719634985

// teoria allows for crazy chaining:
teoria.note(&#x27;a&#x27;)    // Create a note, A3
  .scale(&#x27;lydian&#x27;)  // Create a lydian scale with that note as root (A lydian)
  .interval(&#x27;M2&#x27;)   // Transpose the whole scale a major second up (B lydian)
  .<span class="apidocCodeKeywordSpan">get</span>(&#x27;third&#x27;)     // Get the third note of the scale (D#4)
  .chord(&#x27;maj9&#x27;)    // Create a maj9 chord with that note as root (D#maj9)
  .toString();      // Make a string representation: &#x27;D#maj9&#x27;
```

Documentation
------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.interval" id="apidoc.element.teoria.Chord.prototype.interval">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>interval
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (interval) {
  return new Chord(this.root.interval(interval), this.symbol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.<span class="apidocCodeKeywordSpan">interval</span>(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.notes" id="apidoc.element.teoria.Chord.prototype.notes">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>notes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notes = function () {
  var root = this.root;
  return this.voicing().map(function(interval) {
    return root.interval(interval);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
that represents the current voicing of the chord.

Here&#x27;s an example:
```javascript
var bbmaj = teoria.chord(&#x27;Bbmaj7&#x27;);
// Default voicing:
bbmaj.voicing();  // #-&#x3e; [&#x27;P1&#x27;, &#x27;M3&#x27;, &#x27;P5&#x27;, &#x27;M7&#x27;];
bbmaj.<span class="apidocCodeKeywordSpan">notes</span>();    // #-&#x3e; [&#x27;bb&#x27;, &#x27;d&#x27;, &#x27;f&#x27;, &#x27;a&#
x27;];

// New voicing
bbmaj.voicing([&#x27;P1&#x27;, &#x27;P5&#x27;, &#x27;M7&#x27;, &#x27;M10&#x27;]);
bbmaj.notes();    // #-&#x3e; [&#x27;bb&#x27;, &#x27;f&#x27;, &#x27;a&#x27;, &#x27;d&#x27;];
```
*NB:* Note that above returned results are pseudo-results, as they will be
returned wrapped in `Interval` and `Note` objects.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.parallel" id="apidoc.element.teoria.Chord.prototype.parallel">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>parallel
        <span class="apidocSignatureSpan">(additional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parallel = function (additional) {
  additional = additional || &#x27;&#x27;;
  var quality = this.quality();

  if (this.chordType() !== &#x27;triad&#x27; || quality === &#x27;diminished&#x27; ||
      quality === &#x27;augmented&#x27;) {
    throw new Error(&#x27;Only major/minor triads have parallel chords&#x27;);
  }

  if (quality === &#x27;major&#x27;) {
    return new Chord(this.root.interval(&#x27;m3&#x27;, &#x27;down&#x27;), &#x27;m&#x27;);
  } else {
    return new Chord(this.root.interval(&#x27;m3&#x27;, &#x27;up&#x27;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.quality" id="apidoc.element.teoria.Chord.prototype.quality">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>quality
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quality = function () {
  var third, fifth, seventh, intervals = this.intervals;

  for (var i = 0, length = intervals.length; i &#x3c; length; i++) {
    if (intervals[i].number() === 3) {
      third = intervals[i];
    } else if (intervals[i].number() === 5) {
      fifth = intervals[i];
    } else if (intervals[i].number() === 7) {
      seventh = intervals[i];
    }
  }

  if (!third) {
    return;
  }

  third = (third.direction() === &#x27;down&#x27;) ? third.invert() : third;
  third = third.simple().toString();

  if (fifth) {
    fifth = (fifth.direction === &#x27;down&#x27;) ? fifth.invert() : fifth;
    fifth = fifth.simple().toString();
  }

  if (seventh) {
    seventh = (seventh.direction === &#x27;down&#x27;) ? seventh.invert() : seventh;
    seventh = seventh.simple().toString();
  }

  if (third === &#x27;M3&#x27;) {
    if (fifth === &#x27;A5&#x27;) {
      return &#x27;augmented&#x27;;
    } else if (fifth === &#x27;P5&#x27;) {
      return (seventh === &#x27;m7&#x27;) ? &#x27;dominant&#x27; : &#x27;major&#x27;;
    }

    return &#x27;major&#x27;;
  } else if (third === &#x27;m3&#x27;) {
    if (fifth === &#x27;P5&#x27;) {
      return &#x27;minor&#x27;;
    } else if (fifth === &#x27;d5&#x27;) {
      return (seventh === &#x27;m7&#x27;) ? &#x27;half-diminished&#x27; : &#x27;diminished&#x27;;
    }

    return &#x27;minor&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Interval.base()
- Returns the name of the simple interval (not compound)

#### Interval.type()
- Returns the type of array, either `&#x27;perfect&#x27;` (1, 4, 5, 8) or `&#x27;minor&#x27;` (2, 3, 6, 7)

#### Interval.<span class="apidocCodeKeywordSpan">quality</span>([verbose])
- The quality of the interval (`&#x27;dd&#x27;`, `&#x27;d&#x27;` `&#x27;m&#x27;`, `&#x27;P&#x27;`, `&#x27;M&#x27;`, `&#x27;A&#x27
;` or `&#x27;AA&#x27;`)

*verbose*  is set to a truish value, then long quality names are returned:
`&#x27;doubly diminished&#x27;`, `&#x27;diminished&#x27;`, `&#x27;minor&#x27;`, etc.

#### Interval.direction([dir])
- The direction of the interval
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.resetVoicing" id="apidoc.element.teoria.Chord.prototype.resetVoicing">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>resetVoicing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetVoicing = function () {
  this._voicing = this.intervals;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.simple" id="apidoc.element.teoria.Chord.prototype.simple">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>simple
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simple = function () {
  return this.notes().map(function(n) { return n.toString(true); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).<span class="apidocCodeKeywordSpan">simple</span>();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#
x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.subdominant" id="apidoc.element.teoria.Chord.prototype.subdominant">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>subdominant
        <span class="apidocSignatureSpan">(additional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subdominant = function (additional) {
  additional = additional || &#x27;&#x27;;
  return new Chord(this.root.interval(&#x27;P4&#x27;), additional);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.toString" id="apidoc.element.teoria.Chord.prototype.toString">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
noteConstructor.fromMIDI = Note.fromMIDI;

function chordConstructor(name, symbol) {
if (typeof name === &#x27;string&#x27;) {
  var root, octave;
  root = name.match(/^([a-h])(x|#|bb|b?)/i);
  if (root &#x26;&#x26; root[0]) {
    octave = typeof symbol === &#x27;number&#x27; ? symbol.<span class="apidocCodeKeywordSpan">toString</span>(10) : &#x27;4&#x27
;;
    return new Chord(Note.fromString(root[0].toLowerCase() + octave),
                          name.substr(root[0].length));
  }
} else if (name instanceof Note)
  return new Chord(name, symbol);

throw new Error(&#x27;Invalid Chord. Couldn\&#x27;t find note name&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.transpose" id="apidoc.element.teoria.Chord.prototype.transpose">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>transpose
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (interval) {
  this.root.transpose(interval);
  this.name = this.root.name().toUpperCase() +
              this.root.accidental() + this.symbol;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

interval: function(interval) {
  return new Chord(this.root.interval(interval), this.symbol);
},

transpose: function(interval) {
  this.root.<span class="apidocCodeKeywordSpan">transpose</span>(interval);
  this.name = this.root.name().toUpperCase() +
              this.root.accidental() + this.symbol;

  return this;
},

toString: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Chord.prototype.voicing" id="apidoc.element.teoria.Chord.prototype.voicing">
        function <span class="apidocSignatureSpan">teoria.Chord.prototype.</span>voicing
        <span class="apidocSignatureSpan">(voicing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voicing = function (voicing) {
  // Get the voicing
  if (!voicing) {
    return this._voicing;
  }

  // Set the voicing
  this._voicing = [];
  for (var i = 0, length = voicing.length; i &#x3c; length; i++) {
    this._voicing[i] = Interval.toCoord(voicing[i]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*voicing* - An optional array of intervals in simple-format
that represents the current voicing of the chord.

Here&#x27;s an example:
```javascript
var bbmaj = teoria.chord(&#x27;Bbmaj7&#x27;);
// Default voicing:
bbmaj.<span class="apidocCodeKeywordSpan">voicing</span>();  // #-&#x3e; [&#x27;P1&#x27;, &#x27;M3&#x27;, &#x27;P5&#x27;, &#x27;
M7&#x27;];
bbmaj.notes();    // #-&#x3e; [&#x27;bb&#x27;, &#x27;d&#x27;, &#x27;f&#x27;, &#x27;a&#x27;];

// New voicing
bbmaj.voicing([&#x27;P1&#x27;, &#x27;P5&#x27;, &#x27;M7&#x27;, &#x27;M10&#x27;]);
bbmaj.notes();    // #-&#x3e; [&#x27;bb&#x27;, &#x27;f&#x27;, &#x27;a&#x27;, &#x27;d&#x27;];
```
*NB:* Note that above returned results are pseudo-results, as they will be
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Interval" id="apidoc.module.teoria.Interval">module teoria.Interval</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Interval.Interval" id="apidoc.element.teoria.Interval.Interval">
        function <span class="apidocSignatureSpan">teoria.</span>Interval
        <span class="apidocSignatureSpan">(coord)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Interval(coord) {
  if (!(this instanceof Interval)) return new Interval(coord);
  this.coord = coord;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.between" id="apidoc.element.teoria.Interval.between">
        function <span class="apidocSignatureSpan">teoria.Interval.</span>between
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">between = function (from, to) {
  return new Interval(vector.sub(to.coord, from.coord));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
    return Interval.from(from, Interval.toCoord(to));

  if (to instanceof Interval &#x26;&#x26; from instanceof Note)
    return Interval.from(from, to);

  if (to instanceof Note &#x26;&#x26; from instanceof Note)
    return Interval.<span class="apidocCodeKeywordSpan">between</span>(from, to);

  throw new Error(&#x27;Invalid parameters&#x27;);
}

intervalConstructor.toCoord = Interval.toCoord;
intervalConstructor.from = Interval.from;
intervalConstructor.between = Interval.between;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.from" id="apidoc.element.teoria.Interval.from">
        function <span class="apidocSignatureSpan">teoria.Interval.</span>from
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (from, to) {
  return from.interval(to);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// never thought I would write this, but: Legacy support
function intervalConstructor(from, to) {
// Construct a Interval object from string representation
if (typeof from === &#x27;string&#x27;)
  return Interval.toCoord(from);

if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
  return Interval.<span class="apidocCodeKeywordSpan">from</span>(from, Interval.toCoord(to));

if (to instanceof Interval &#x26;&#x26; from instanceof Note)
  return Interval.from(from, to);

if (to instanceof Note &#x26;&#x26; from instanceof Note)
  return Interval.between(from, to);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.invert" id="apidoc.element.teoria.Interval.invert">
        function <span class="apidocSignatureSpan">teoria.Interval.</span>invert
        <span class="apidocSignatureSpan">(sInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (sInterval) {
  return Interval.toCoord(sInterval).invert().toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).<span class="apidocCodeKeywordSpan">invert</span>(); // Returns a Interval representing
 a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.toCoord" id="apidoc.element.teoria.Interval.toCoord">
        function <span class="apidocSignatureSpan">teoria.Interval.</span>toCoord
        <span class="apidocSignatureSpan">(simple)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toCoord = function (simple) {
  var coord = toCoord(simple);
  if (!coord)
    throw new Error(&#x27;Invalid simple format interval&#x27;);

  return new Interval(coord);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var teoria;

// never thought I would write this, but: Legacy support
function intervalConstructor(from, to) {
// Construct a Interval object from string representation
if (typeof from === &#x27;string&#x27;)
  return Interval.<span class="apidocCodeKeywordSpan">toCoord</span>(from);

if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
  return Interval.from(from, Interval.toCoord(to));

if (to instanceof Interval &#x26;&#x26; from instanceof Note)
  return Interval.from(from, to);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Interval.prototype" id="apidoc.module.teoria.Interval.prototype">module teoria.Interval.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.add" id="apidoc.element.teoria.Interval.prototype.add">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>add
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (interval) {
  return new Interval(vector.add(this.coord, interval.coord));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.value() &#x3e;= 1 ? &#x27;up&#x27; : &#x27;down&#x27;;
},

simple: function(ignore) {
  // Get the (upwards) base interval (with quality)
  var simple = knowledge.intervals[this.base()];
  var toAdd = vector.mul(knowledge.sharp, this.qualityValue());
  simple = vector.<span class="apidocCodeKeywordSpan">add</span>(simple, toAdd);

  // Turn it around if necessary
  if (!ignore)
    simple = this.direction() === &#x27;down&#x27; ? vector.mul(simple, -1) : simple;

  return new Interval(simple);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.base" id="apidoc.element.teoria.Interval.prototype.base">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>base
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function () {
  var product = vector.mul(knowledge.sharp, this.qualityValue());
  var fifth = vector.sub(this.coord, product)[1];
  fifth = this.value() &#x3e; 0 ? fifth + 5 : -(fifth - 5) % 7;
  fifth = fifth &#x3c; 0 ? knowledge.intervalFromFifth.length + fifth : fifth;

  var name = knowledge.intervalFromFifth[fifth];
  if (name === &#x27;unison&#x27; &#x26;&#x26; this.number() &#x3e;= 8)
    name = &#x27;octave&#x27;;

  return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Interval.value()
- The value of the interval - That is a ninth = 9, but a downwards ninth is = -9

#### Interval.toString()
- Returns the *simpleInterval* representation of the interval. E.g. `&#x27;P5&#x27;`,
`&#x27;M3&#x27;`, `&#x27;A9&#x27;`, etc.

#### Interval.<span class="apidocCodeKeywordSpan">base</span>()
- Returns the name of the simple interval (not compound)

#### Interval.type()
- Returns the type of array, either `&#x27;perfect&#x27;` (1, 4, 5, 8) or `&#x27;minor&#x27;` (2, 3, 6, 7)

#### Interval.quality([verbose])
- The quality of the interval (`&#x27;dd&#x27;`, `&#x27;d&#x27;` `&#x27;m&#x27;`, `&#x27;P&#x27;`, `&#x27;M&#x27;`, `&#x27;A&#x27
;` or `&#x27;AA&#x27;`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.direction" id="apidoc.element.teoria.Interval.prototype.direction">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>direction
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">direction = function (dir) {
  if (dir) {
    var is = this.value() &#x3e;= 1 ? &#x27;up&#x27; : &#x27;down&#x27;;
    if (is !== dir)
      this.coord = vector.mul(this.coord, -1);

    return this;
  }
  else
    return this.value() &#x3e;= 1 ? &#x27;up&#x27; : &#x27;down&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Interval.quality([verbose])
- The quality of the interval (`&#x27;dd&#x27;`, `&#x27;d&#x27;` `&#x27;m&#x27;`, `&#x27;P&#x27;`, `&#x27;M&#x27;`, `&#x27;A&#x27
;` or `&#x27;AA&#x27;`)

*verbose*  is set to a truish value, then long quality names are returned:
`&#x27;doubly diminished&#x27;`, `&#x27;diminished&#x27;`, `&#x27;minor&#x27;`, etc.

#### Interval.<span class="apidocCodeKeywordSpan">direction</span>([dir])
- The direction of the interval

*dir* - If supplied, then the interval&#x27;s direction is to the `newDirection`
which is either `&#x27;up&#x27;` or `&#x27;down&#x27;`

#### Interval#semitones()
- Returns the `number` of semitones the interval span.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.equal" id="apidoc.element.teoria.Interval.prototype.equal">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>equal
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equal = function (interval) {
    return this.coord[0] === interval.coord[0] &#x26;&#x26;
        this.coord[1] === interval.coord[1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  bassInterval = Interval.between(root, note);
  bass = bassInterval.simple();
  bassInterval = bassInterval.invert().direction(&#x27;down&#x27;);

  this._voicing = [bassInterval];
  for (var i = 0, length = intervals.length;  i &#x3c; length; i++) {
    if (!intervals[i].simple().<span class="apidocCodeKeywordSpan">equal</span>(bass))
      this._voicing.push(intervals[i]);
  }
}
}

Chord.prototype = {
notes: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.greater" id="apidoc.element.teoria.Interval.prototype.greater">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>greater
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greater = function (interval) {
  var semi = this.semitones();
  var isemi = interval.semitones();

  // If equal in absolute size, measure which interval is bigger
  // For example P4 is bigger than A3
  return (semi === isemi) ?
    (this.number() &#x3e; interval.number()) : (semi &#x3e; isemi);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // If equal in absolute size, measure which interval is bigger
  // For example P4 is bigger than A3
  return (semi === isemi) ?
    (this.number() &#x3e; interval.number()) : (semi &#x3e; isemi);
},

smaller: function(interval) {
  return !this.equal(interval) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">greater</span>(interval);
},

add: function(interval) {
  return new Interval(vector.add(this.coord, interval.coord));
},

toString: function(ignore) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.invert" id="apidoc.element.teoria.Interval.prototype.invert">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function () {
  var i = this.base();
  var qual = this.qualityValue();
  var acc = this.type() === &#x27;minor&#x27; ? -(qual - 1) : -qual;
  var idx = 9 - knowledge.stepNumber[i] - 1;
  var coord = knowledge.intervals[knowledge.intervalsIndex[idx]];
  coord = vector.add(coord, vector.mul(knowledge.sharp, acc));

  return new Interval(coord);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).<span class="apidocCodeKeywordSpan">invert</span>(); // Returns a Interval representing
 a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.isCompound" id="apidoc.element.teoria.Interval.prototype.isCompound">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>isCompound
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCompound = function () {
  return this.number() &#x3e; 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.name" id="apidoc.element.teoria.Interval.prototype.name">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">name = function () {
  return knowledge.intervalsIndex[this.number() - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### teoria.note.fromString(note)
 - Returns an instance of Note representing the note name

*note* - The name argument is the note name as a string. The note can both
be expressed in scientific and Helmholtz notation.
Some examples of valid note names: `Eb4`, `C#,,`, `C4`, `d#&#x27;&#x27;`, `Ab2`

#### Note.<span class="apidocCodeKeywordSpan">name</span>()
 - The name of the note, in lowercase letter (*only* the name, not the
 accidental signs)

#### Note.octave()
 - The numeric value of the octave of the note

#### Note.duration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.number" id="apidoc.element.teoria.Interval.prototype.number">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>number
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number = function () {
  return Math.abs(this.value());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The number may be prefixed with a `-` to signify that its direction is down. E.g.:

`m-3` means a descending minor third, and `P-5` means a descending perfect fifth.

#### Interval.coord
- The interval representation of the interval

#### Interval.<span class="apidocCodeKeywordSpan">number</span>()
- The interval number (A ninth = 9, A seventh = 7, fifteenth = 15)

#### Interval.value()
- The value of the interval - That is a ninth = 9, but a downwards ninth is = -9

#### Interval.toString()
- Returns the *simpleInterval* representation of the interval. E.g. `&#x27;P5&#x27;`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.octaves" id="apidoc.element.teoria.Interval.prototype.octaves">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>octaves
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">octaves = function () {
  var toSubtract, without, octaves;

  if (this.direction() === &#x27;up&#x27;) {
    toSubtract = vector.mul(knowledge.sharp, this.qualityValue());
    without = vector.sub(this.coord, toSubtract);
    octaves = without[0] - knowledge.intervals[this.base()][0];
  } else {
    toSubtract = vector.mul(knowledge.sharp, -this.qualityValue());
    without = vector.sub(this.coord, toSubtract);
    octaves = -(without[0] + knowledge.intervals[this.base()][0]);
  }

  return octaves;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.quality" id="apidoc.element.teoria.Interval.prototype.quality">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>quality
        <span class="apidocSignatureSpan">(lng)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quality = function (lng) {
  var quality = knowledge.alterations[this.type()][this.qualityValue() + 2];

  return lng ? knowledge.qualityLong[quality] : quality;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Interval.base()
- Returns the name of the simple interval (not compound)

#### Interval.type()
- Returns the type of array, either `&#x27;perfect&#x27;` (1, 4, 5, 8) or `&#x27;minor&#x27;` (2, 3, 6, 7)

#### Interval.<span class="apidocCodeKeywordSpan">quality</span>([verbose])
- The quality of the interval (`&#x27;dd&#x27;`, `&#x27;d&#x27;` `&#x27;m&#x27;`, `&#x27;P&#x27;`, `&#x27;M&#x27;`, `&#x27;A&#x27
;` or `&#x27;AA&#x27;`)

*verbose*  is set to a truish value, then long quality names are returned:
`&#x27;doubly diminished&#x27;`, `&#x27;diminished&#x27;`, `&#x27;minor&#x27;`, etc.

#### Interval.direction([dir])
- The direction of the interval
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.qualityValue" id="apidoc.element.teoria.Interval.prototype.qualityValue">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>qualityValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qualityValue = function () {
  if (this.direction() === &#x27;down&#x27;)
    return Math.floor((-this.coord[1] - 2) / 7) + 1;
  else
    return Math.floor((this.coord[1] - 2) / 7) + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  type: function() {
return knowledge.intervals[this.base()][0] &#x3c;= 1 ? &#x27;perfect&#x27; : &#x27;minor&#x27;;
  },

  base: function() {
var product = vector.mul(knowledge.sharp, this.<span class="apidocCodeKeywordSpan">qualityValue</span>());
var fifth = vector.sub(this.coord, product)[1];
fifth = this.value() &#x3e; 0 ? fifth + 5 : -(fifth - 5) % 7;
fifth = fifth &#x3c; 0 ? knowledge.intervalFromFifth.length + fifth : fifth;

var name = knowledge.intervalFromFifth[fifth];
if (name === &#x27;unison&#x27; &#x26;&#x26; this.number() &#x3e;= 8)
  name = &#x27;octave&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.semitones" id="apidoc.element.teoria.Interval.prototype.semitones">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>semitones
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">semitones = function () {
  return vector.sum(vector.mul(this.coord, [12, 7]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

equal: function(interval) {
    return this.coord[0] === interval.coord[0] &#x26;&#x26;
        this.coord[1] === interval.coord[1];
},

greater: function(interval) {
  var semi = this.<span class="apidocCodeKeywordSpan">semitones</span>();
  var isemi = interval.semitones();

  // If equal in absolute size, measure which interval is bigger
  // For example P4 is bigger than A3
  return (semi === isemi) ?
    (this.number() &#x3e; interval.number()) : (semi &#x3e; isemi);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.simple" id="apidoc.element.teoria.Interval.prototype.simple">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>simple
        <span class="apidocSignatureSpan">(ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simple = function (ignore) {
  // Get the (upwards) base interval (with quality)
  var simple = knowledge.intervals[this.base()];
  var toAdd = vector.mul(knowledge.sharp, this.qualityValue());
  simple = vector.add(simple, toAdd);

  // Turn it around if necessary
  if (!ignore)
    simple = this.direction() === &#x27;down&#x27; ? vector.mul(simple, -1) : simple;

  return new Interval(simple);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).<span class="apidocCodeKeywordSpan">simple</span>();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#
x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.smaller" id="apidoc.element.teoria.Interval.prototype.smaller">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>smaller
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">smaller = function (interval) {
  return !this.equal(interval) &#x26;&#x26; !this.greater(interval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.toString" id="apidoc.element.teoria.Interval.prototype.toString">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>toString
        <span class="apidocSignatureSpan">(ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (ignore) {
  // If given true, return the positive value
  var number = ignore ? this.number() : this.value();

  return this.quality() + number;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
noteConstructor.fromMIDI = Note.fromMIDI;

function chordConstructor(name, symbol) {
if (typeof name === &#x27;string&#x27;) {
  var root, octave;
  root = name.match(/^([a-h])(x|#|bb|b?)/i);
  if (root &#x26;&#x26; root[0]) {
    octave = typeof symbol === &#x27;number&#x27; ? symbol.<span class="apidocCodeKeywordSpan">toString</span>(10) : &#x27;4&#x27
;;
    return new Chord(Note.fromString(root[0].toLowerCase() + octave),
                          name.substr(root[0].length));
  }
} else if (name instanceof Note)
  return new Chord(name, symbol);

throw new Error(&#x27;Invalid Chord. Couldn\&#x27;t find note name&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.type" id="apidoc.element.teoria.Interval.prototype.type">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
  return knowledge.intervals[this.base()][0] &#x3c;= 1 ? &#x27;perfect&#x27; : &#x27;minor&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Interval.toString()
- Returns the *simpleInterval* representation of the interval. E.g. `&#x27;P5&#x27;`,
`&#x27;M3&#x27;`, `&#x27;A9&#x27;`, etc.

#### Interval.base()
- Returns the name of the simple interval (not compound)

#### Interval.<span class="apidocCodeKeywordSpan">type</span>()
- Returns the type of array, either `&#x27;perfect&#x27;` (1, 4, 5, 8) or `&#x27;minor&#x27;` (2, 3, 6, 7)

#### Interval.quality([verbose])
- The quality of the interval (`&#x27;dd&#x27;`, `&#x27;d&#x27;` `&#x27;m&#x27;`, `&#x27;P&#x27;`, `&#x27;M&#x27;`, `&#x27;A&#x27
;` or `&#x27;AA&#x27;`)

*verbose*  is set to a truish value, then long quality names are returned:
`&#x27;doubly diminished&#x27;`, `&#x27;diminished&#x27;`, `&#x27;minor&#x27;`, etc.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Interval.prototype.value" id="apidoc.element.teoria.Interval.prototype.value">
        function <span class="apidocSignatureSpan">teoria.Interval.prototype.</span>value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value = function () {
  var toMultiply = Math.floor((this.coord[1] - 2) / 7) + 1;
  var product = vector.mul(knowledge.sharp, toMultiply);
  var without = vector.sub(this.coord, product);
  var i = knowledge.intervalFromFifth[without[1] + 5];
  var diff = without[0] - knowledge.intervals[i][0];
  var val = knowledge.stepNumber[i] + diff * 7;

  return (val &#x3e; 0) ? val : val - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Interval.coord
 - The interval representation of the interval

#### Interval.number()
 - The interval number (A ninth = 9, A seventh = 7, fifteenth = 15)

#### Interval.<span class="apidocCodeKeywordSpan">value</span>()
 - The value of the interval - That is a ninth = 9, but a downwards ninth is = -9

#### Interval.toString()
 - Returns the *simpleInterval* representation of the interval. E.g. `&#x27;P5&#x27;`,
 `&#x27;M3&#x27;`, `&#x27;A9&#x27;`, etc.

#### Interval.base()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Note" id="apidoc.module.teoria.Note">module teoria.Note</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Note.Note" id="apidoc.element.teoria.Note.Note">
        function <span class="apidocSignatureSpan">teoria.</span>Note
        <span class="apidocSignatureSpan">(coord, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Note(coord, duration) {
  if (!(this instanceof Note)) return new Note(coord, duration);
  duration = duration || {};

  this.duration = { value: duration.value || 4, dots: duration.dots || 0 };
  this.coord = coord;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.fromFrequency" id="apidoc.element.teoria.Note.fromFrequency">
        function <span class="apidocSignatureSpan">teoria.Note.</span>fromFrequency
        <span class="apidocSignatureSpan">(fq, concertPitch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromFrequency = function (fq, concertPitch) {
  var key, cents, originalFq;
  concertPitch = concertPitch || 440;

  key = 49 + 12 * ((Math.log(fq) - Math.log(concertPitch)) / Math.log(2));
  key = Math.round(key);
  originalFq = concertPitch * Math.pow(2, (key - 49) / 12);
  cents = 1200 * (Math.log(fq / originalFq) / Math.log(2));

  return { note: Note.fromKey(key), cents: cents };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
teoria.chord(&#x27;Ab#5b9&#x27;);   // Returns a Chord object, representing a Ab#5b9 chord
g5.chord(&#x27;dim&#x27;);          // Returns a Chord object, representing a Gdim chord

// Calculate note frequencies or find the note corresponding to a frequency
teoria.note.<span class="apidocCodeKeywordSpan">fromFrequency</span>(467); // Returns: {&#x27;note&#x27;:{...},&#x27;cents&#x27;:
3.102831} -&#x3e; A4# a little out of tune.
a4.fq(); // Outputs 440
g5.fq(); // Outputs 783.9908719634985

// teoria allows for crazy chaining:
teoria.note(&#x27;a&#x27;)    // Create a note, A3
.scale(&#x27;lydian&#x27;)  // Create a lydian scale with that note as root (A lydian)
.interval(&#x27;M2&#x27;)   // Transpose the whole scale a major second up (B lydian)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.fromKey" id="apidoc.element.teoria.Note.fromKey">
        function <span class="apidocSignatureSpan">teoria.Note.</span>fromKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromKey = function (key) {
  var octave = Math.floor((key - 4) / 12);
  var distance = key - (octave * 12) - 4;
  var name = knowledge.fifths[(2 * Math.round(distance / 2) + 1) % 7];
  var subDiff = vector.sub(knowledge.notes[name], knowledge.A4);
  var note = vector.add(subDiff, [octave + 1, 0]);
  var diff = (key - 49) - vector.sum(vector.mul(note, [12, 7]));

  var arg = diff ? vector.add(note, vector.mul(knowledge.sharp, diff)) : note;
  return new Note(arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for a technical library reference, look further down this document.

```javascript

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.<span class="apidocCodeKeywordSpan">fromKey</span>(28); // From a piano key number

// Find and create notes based on intervals
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.fromMIDI" id="apidoc.element.teoria.Note.fromMIDI">
        function <span class="apidocSignatureSpan">teoria.Note.</span>fromMIDI
        <span class="apidocSignatureSpan">(note)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromMIDI = function (note) {
  return Note.fromKey(note - 20);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### teoria.note.fromFrequency(fq)
A static method returns an object containing two elements:

*note* - A `Note` which corresponds to the closest note with the given frequency

*cents* - A number value of how many cents the note is out of tune

### teoria.note.<span class="apidocCodeKeywordSpan">fromMIDI</span>(note)
- Returns an instance of Note set to the corresponding MIDI note value.

*note* - A number ranging from 0-127 representing a MIDI note value

### teoria.note.fromString(note)
- Returns an instance of Note representing the note name
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.fromString" id="apidoc.element.teoria.Note.fromString">
        function <span class="apidocSignatureSpan">teoria.Note.</span>fromString
        <span class="apidocSignatureSpan">(name, dur)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (name, dur) {
  var coord = scientific(name);
  if (!coord) coord = helmholtz(name);
  return new Note(coord, dur);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
intervalConstructor.toCoord = Interval.toCoord;
intervalConstructor.from = Interval.from;
intervalConstructor.between = Interval.between;
intervalConstructor.invert = Interval.invert;

function noteConstructor(name, duration) {
  if (typeof name === &#x27;string&#x27;)
    return Note.<span class="apidocCodeKeywordSpan">fromString</span>(name, duration);
  else
    return new Note(name, duration);
}

noteConstructor.fromString = Note.fromString;
noteConstructor.fromKey = Note.fromKey;
noteConstructor.fromFrequency = Note.fromFrequency;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Note.prototype" id="apidoc.module.teoria.Note.prototype">module teoria.Note.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.accidental" id="apidoc.element.teoria.Note.prototype.accidental">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>accidental
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accidental = function () {
  return knowledge.accidentals[this.accidentalValue() + 2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Note.octave()
 - The numeric value of the octave of the note

#### Note.duration
 - The duration object as described in the constructor for Note

#### Note.<span class="apidocCodeKeywordSpan">accidental</span>()
 - Returns the string symbolic of the accidental sign (`x`, `#`, `b` or `bb`)

#### Note.accidentalValue()
 - Returns the numeric value (mostly used internally) of the sign:
`x = 2, # = 1, b = -1, bb = -2`

#### Note#key([whitenotes])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.accidentalValue" id="apidoc.element.teoria.Note.prototype.accidentalValue">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>accidentalValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accidentalValue = function () {
  return Math.round((this.coord[1] + knowledge.A4[1] - 2) / 7);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Note.duration
 - The duration object as described in the constructor for Note

#### Note.accidental()
 - Returns the string symbolic of the accidental sign (`x`, `#`, `b` or `bb`)

#### Note.<span class="apidocCodeKeywordSpan">accidentalValue</span>()
 - Returns the numeric value (mostly used internally) of the sign:
`x = 2, # = 1, b = -1, bb = -2`

#### Note#key([whitenotes])
 - Returns the piano key number. E.g. A4 would return 49

*whitenotes* - If this parameter is set to `true` only the white keys will
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.chord" id="apidoc.element.teoria.Note.prototype.chord">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>chord
        <span class="apidocSignatureSpan">(chord)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chord = function (chord) {
  var isShortChord = chord in knowledge.chordShort;
  chord = isShortChord ? knowledge.chordShort[chord] : chord;

  return new Chord(this, chord);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.<span class="apidocCodeKeywordSpan">chord</span>(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27
;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
teoria.chord(&#x27;Ab#5b9&#x27;);   // Returns a Chord object, representing a Ab#5b9 chord
g5.chord(&#x27;dim&#x27;);          // Returns a Chord object, representing a Gdim chord

// Calculate note frequencies or find the note corresponding to a frequency
teoria.note.fromFrequency(467); // Returns: {&#x27;note&#x27;:{...},&#x27;cents&#x27;:3.102831} -&#x3e; A4# a little out of tune
.
a4.fq(); // Outputs 440
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.chroma" id="apidoc.element.teoria.Note.prototype.chroma">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>chroma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chroma = function () {
  var value = (vector.sum(vector.mul(this.coord, [12, 7])) - 3) % 12;

  return (value &#x3c; 0) ? value + 12 : value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
concert pitch which is 440hz. This is useful for some classical music.

#### Note#chroma()
 - Returns the pitch class (index) of the note.

This allows for easy enharmonic checking:

    teoria.note(&#x27;e&#x27;).<span class="apidocCodeKeywordSpan">chroma</span>() === teoria.note(&#x27;fb&#x27;).chroma();

The chroma number is ranging from pitch class C which is 0 to 11 which is B

#### Note#scale(scaleName)
 - Returns an instance of Scale, with the tonic/root set to this note.

*scaleName* - The name of the scale to be returned. `&#x27;minor&#x27;`,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.durationInSeconds" id="apidoc.element.teoria.Note.prototype.durationInSeconds">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>durationInSeconds
        <span class="apidocSignatureSpan">(bpm, beatUnit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">durationInSeconds = function (bpm, beatUnit) {
  var secs = (60 / bpm) / (this.duration.value / 4) / (beatUnit / 4);
  return secs * 2 - secs / Math.pow(2, this.duration.dots);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.durationName" id="apidoc.element.teoria.Note.prototype.durationName">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>durationName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">durationName = function () {
  return knowledge.durations[this.duration.value];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*showOctaves* - A boolean. If set to true, a &#x22;Helmholtz-like&#x22; notation will be
used if there&#x27;s bigger intervals than an octave

#### Note#durationName()
- Returns the duration name.

Examples: `teoria.note(&#x27;A&#x27;, 8).<span class="apidocCodeKeywordSpan">durationName</span>() -&#x3e; &#x27;eighth&#x27;`,
`teoria.note(&#x27;C&#x27;, 16).durationName() -&#x3e; &#x27;sixteenth&#x27;`

#### Note#scaleDegree(scale)
- Returns this note&#x27;s degree in a given scale (Scale). For example a
`D` in a C major scale will return `2` as it is the second degree of that scale.
If however the note *isn&#x27;t* a part of the scale, the degree returned will be
`0`, meaning that the degree doesn&#x27;t exist. This allows this method to be both
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.enharmonics" id="apidoc.element.teoria.Note.prototype.enharmonics">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>enharmonics
        <span class="apidocSignatureSpan">(oneaccidental)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enharmonics = function (oneaccidental) {
  var key = this.key(), limit = oneaccidental ? 2 : 3;

  return [&#x27;m3&#x27;, &#x27;m2&#x27;, &#x27;m-2&#x27;, &#x27;m-3&#x27;]
    .map(this.interval.bind(this))
    .filter(function(note) {
    var acc = note.accidentalValue();
    var diff = key - (note.key() - acc);

    if (diff &#x3c; limit &#x26;&#x26; diff &#x3e; -limit) {
      var product = vector.mul(knowledge.sharp, diff - acc);
      note.coord = vector.add(note.coord, product);
      return true;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Note#enharmonics(oneAccidental)
 - Returns all notes that are enharmonic with the note

*oneAccidental* - Boolean, if set to true, only enharmonic notes with one
accidental is returned. E.g. results such as &#x27;eb&#x27; and &#x27;c#&#x27; but not &#x27;ebb&#x27; and &#x27;cx&#x27;

```javascript
teoria.note(&#x27;c&#x27;).<span class="apidocCodeKeywordSpan">enharmonics</span>().toString();
// -&#x3e; &#x27;dbb, b#&#x27;

teoria.note(&#x27;c&#x27;).enharmonics(true).toString();
// -&#x3e; &#x27;b#&#x27;
```

#### Note#durationInSeconds(bpm, beatUnit)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.fq" id="apidoc.element.teoria.Note.prototype.fq">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>fq
        <span class="apidocSignatureSpan">(concertPitch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fq = function (concertPitch) {
  return pitchFq(this.coord, concertPitch);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
teoria.chord(&#x27;Ab#5b9&#x27;);   // Returns a Chord object, representing a Ab#5b9 chord
g5.chord(&#x27;dim&#x27;);          // Returns a Chord object, representing a Gdim chord

// Calculate note frequencies or find the note corresponding to a frequency
teoria.note.fromFrequency(467); // Returns: {&#x27;note&#x27;:{...},&#x27;cents&#x27;:3.102831} -&#x3e; A4# a little out of tune
.
a4.<span class="apidocCodeKeywordSpan">fq</span>(); // Outputs 440
g5.fq(); // Outputs 783.9908719634985

// teoria allows for crazy chaining:
teoria.note(&#x27;a&#x27;)    // Create a note, A3
.scale(&#x27;lydian&#x27;)  // Create a lydian scale with that note as root (A lydian)
.interval(&#x27;M2&#x27;)   // Transpose the whole scale a major second up (B lydian)
.get(&#x27;third&#x27;)     // Get the third note of the scale (D#4)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.helmholtz" id="apidoc.element.teoria.Note.prototype.helmholtz">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>helmholtz
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">helmholtz = function () {
  var octave = this.octave();
  var name = this.name();
  name = octave &#x3c; 3 ? name.toUpperCase() : name.toLowerCase();
  var padchar = octave &#x3c; 3 ? &#x27;,&#x27; : &#x27;\&#x27;&#x27;;
  var padcount = octave &#x3c; 2 ? 2 - octave : octave - 3;

  return pad(name + this.accidental(), padchar, padcount);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*name* - The name attribute is the last part of the chord symbol.
Examples: `&#x27;m7&#x27;`, `&#x27;#5b9&#x27;`, `&#x27;major&#x27;`. If the name parameter
isn&#x27;t set, a standard major chord will be returned.

#### Note#helmholtz()
 - Returns the note name formatted in Helmholtz notation.

Example: `teoria.note(&#x27;A5&#x27;).<span class="apidocCodeKeywordSpan">helmholtz</span>() -&#x3e; &#x22;a&#x27;&#x27;&#x22;`

#### Note#scientific()
 - Returns the note name formatted in scientific notation.

Example: `teoria.note(&#x22;ab&#x27;&#x22;).scientific() -&#x3e; &#x22;Ab4&#x22;`

#### Note#enharmonics(oneAccidental)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.interval" id="apidoc.element.teoria.Note.prototype.interval">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>interval
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (interval) {
  if (typeof interval === &#x27;string&#x27;) interval = Interval.toCoord(interval);

  if (interval instanceof Interval)
    return new Note(vector.add(this.coord, interval.coord));
  else if (interval instanceof Note)
    return new Interval(vector.sub(interval.coord, this.coord));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.<span class="apidocCodeKeywordSpan">interval</span>(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.key" id="apidoc.element.teoria.Note.prototype.key">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>key
        <span class="apidocSignatureSpan">(white)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">key = function (white) {
  if (white)
    return this.coord[0] * 7 + this.coord[1] * 4 + 29;
  else
    return this.coord[0] * 12 + this.coord[1] * 7 + 49;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.coord[0] * 12 + this.coord[1] * 7 + 49;
},

/**
* Returns a number ranging from 0-127 representing a MIDI note value
*/
midi: function() {
  return this.<span class="apidocCodeKeywordSpan">key</span>() + 20;
},

/**
 * Calculates and returns the frequency of the note.
 * Optional concert pitch (def. 440)
 */
fq: function(concertPitch) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.midi" id="apidoc.element.teoria.Note.prototype.midi">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>midi
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">midi = function () {
  return this.key() + 20;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.name" id="apidoc.element.teoria.Note.prototype.name">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">name = function () {
  var value = this.accidentalValue();
  var idx = this.coord[1] + knowledge.A4[1] - value * 7 + 1;
  return knowledge.fifths[idx];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### teoria.note.fromString(note)
 - Returns an instance of Note representing the note name

*note* - The name argument is the note name as a string. The note can both
be expressed in scientific and Helmholtz notation.
Some examples of valid note names: `Eb4`, `C#,,`, `C4`, `d#&#x27;&#x27;`, `Ab2`

#### Note.<span class="apidocCodeKeywordSpan">name</span>()
 - The name of the note, in lowercase letter (*only* the name, not the
 accidental signs)

#### Note.octave()
 - The numeric value of the octave of the note

#### Note.duration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.octave" id="apidoc.element.teoria.Note.prototype.octave">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>octave
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">octave = function () {
  return this.coord[0] + knowledge.A4[0] - knowledge.notes[this.name()][0] +
    this.accidentalValue() * 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
be expressed in scientific and Helmholtz notation.
Some examples of valid note names: `Eb4`, `C#,,`, `C4`, `d#&#x27;&#x27;`, `Ab2`

#### Note.name()
- The name of the note, in lowercase letter (*only* the name, not the
accidental signs)

#### Note.<span class="apidocCodeKeywordSpan">octave</span>()
- The numeric value of the octave of the note

#### Note.duration
- The duration object as described in the constructor for Note

#### Note.accidental()
- Returns the string symbolic of the accidental sign (`x`, `#`, `b` or `bb`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.scale" id="apidoc.element.teoria.Note.prototype.scale">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>scale
        <span class="apidocSignatureSpan">(scale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scale = function (scale) {
  return new Scale(this, scale);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.<span class="apidocCodeKeywordSpan">scale</span>(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#
x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.scaleDegree" id="apidoc.element.teoria.Note.prototype.scaleDegree">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>scaleDegree
        <span class="apidocSignatureSpan">(scale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scaleDegree = function (scale) {
  var inter = scale.tonic.interval(this);

  // If the direction is down, or we&#x27;re dealing with an octave - invert it
  if (inter.direction() === &#x27;down&#x27; ||
     (inter.coord[1] === 0 &#x26;&#x26; inter.coord[0] !== 0)) {
    inter = inter.invert();
  }

  inter = inter.simple(true).coord;

  return scale.scale.reduce(function(index, current, i) {
    var coord = Interval.toCoord(current).coord;
    return coord[0] === inter[0] &#x26;&#x26; coord[1] === inter[1] ? i + 1 : index;
  }, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.scientific" id="apidoc.element.teoria.Note.prototype.scientific">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>scientific
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scientific = function () {
  return this.name().toUpperCase() + this.accidental() + this.octave();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 - Returns the note name formatted in Helmholtz notation.

Example: `teoria.note(&#x27;A5&#x27;).helmholtz() -&#x3e; &#x22;a&#x27;&#x27;&#x22;`

#### Note#scientific()
 - Returns the note name formatted in scientific notation.

Example: `teoria.note(&#x22;ab&#x27;&#x22;).<span class="apidocCodeKeywordSpan">scientific</span>() -&#x3e; &#x22;Ab4&#x22;`

#### Note#enharmonics(oneAccidental)
 - Returns all notes that are enharmonic with the note

*oneAccidental* - Boolean, if set to true, only enharmonic notes with one
accidental is returned. E.g. results such as &#x27;eb&#x27; and &#x27;c#&#x27; but not &#x27;ebb&#x27; and &#x27;cx&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.solfege" id="apidoc.element.teoria.Note.prototype.solfege">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>solfege
        <span class="apidocSignatureSpan">(scale, showOctaves)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solfege = function (scale, showOctaves) {
  var interval = scale.tonic.interval(this), solfege, stroke, count;
  if (interval.direction() === &#x27;down&#x27;)
    interval = interval.invert();

  if (showOctaves) {
    count = (this.key(true) - scale.tonic.key(true)) / 7;
    count = (count &#x3e;= 0) ? Math.floor(count) : -(Math.ceil(-count));
    stroke = (count &#x3e;= 0) ? &#x27;\&#x27;&#x27; : &#x27;,&#x27;;
  }

  solfege = knowledge.intervalSolfege[interval.simple(true).toString()];
  return (showOctaves) ? pad(solfege, stroke, Math.abs(count)) : solfege;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = isStepStr ? knowledge.stepNumber[i] : i;

  return this.tonic.interval(this.scale[i - 1]);
},

solfege: function(index, showOctaves) {
  if (index)
    return this.get(index).<span class="apidocCodeKeywordSpan">solfege</span>(this, showOctaves);

  return this.notes().map(function(n) {
    return n.solfege(this, showOctaves);
  });
},

interval: function(interval) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.toString" id="apidoc.element.teoria.Note.prototype.toString">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>toString
        <span class="apidocSignatureSpan">(dont)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (dont) {
  return this.name() + this.accidental() + (dont ? &#x27;&#x27; : this.octave());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
noteConstructor.fromMIDI = Note.fromMIDI;

function chordConstructor(name, symbol) {
if (typeof name === &#x27;string&#x27;) {
  var root, octave;
  root = name.match(/^([a-h])(x|#|bb|b?)/i);
  if (root &#x26;&#x26; root[0]) {
    octave = typeof symbol === &#x27;number&#x27; ? symbol.<span class="apidocCodeKeywordSpan">toString</span>(10) : &#x27;4&#x27
;;
    return new Chord(Note.fromString(root[0].toLowerCase() + octave),
                          name.substr(root[0].length));
  }
} else if (name instanceof Note)
  return new Chord(name, symbol);

throw new Error(&#x27;Invalid Chord. Couldn\&#x27;t find note name&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Note.prototype.transpose" id="apidoc.element.teoria.Note.prototype.transpose">
        function <span class="apidocSignatureSpan">teoria.Note.prototype.</span>transpose
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (interval) {
  this.coord = vector.add(this.coord, interval.coord);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

interval: function(interval) {
  return new Chord(this.root.interval(interval), this.symbol);
},

transpose: function(interval) {
  this.root.<span class="apidocCodeKeywordSpan">transpose</span>(interval);
  this.name = this.root.name().toUpperCase() +
              this.root.accidental() + this.symbol;

  return this;
},

toString: function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Scale" id="apidoc.module.teoria.Scale">module teoria.Scale</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Scale.Scale" id="apidoc.element.teoria.Scale.Scale">
        function <span class="apidocSignatureSpan">teoria.</span>Scale
        <span class="apidocSignatureSpan">(tonic, scale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scale(tonic, scale) {
  if (!(this instanceof Scale)) return new Scale(tonic, scale);
  var scaleName, i;
  if (!(&#x27;coord&#x27; in tonic)) {
    throw new Error(&#x27;Invalid Tonic&#x27;);
  }

  if (typeof scale === &#x27;string&#x27;) {
    scaleName = scale;
    scale = scales[scale];
    if (!scale)
      throw new Error(&#x27;Invalid Scale&#x27;);
  } else {
    for (i in scales) {
      if (scales.hasOwnProperty(i)) {
        if (scales[i].toString() === scale.toString()) {
          scaleName = i;
          break;
        }
      }
    }
  }

  this.name = scaleName;
  this.tonic = tonic;
  this.scale = scale;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.Scale.prototype" id="apidoc.module.teoria.Scale.prototype">module teoria.Scale.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.get" id="apidoc.element.teoria.Scale.prototype.get">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>get
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (i) {
  var isStepStr = typeof i === &#x27;string&#x27; &#x26;&#x26; i in knowledge.stepNumber;
  i = isStepStr ? knowledge.stepNumber[i] : i;

  return this.tonic.interval(this.scale[i - 1]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a4.fq(); // Outputs 440
g5.fq(); // Outputs 783.9908719634985

// teoria allows for crazy chaining:
teoria.note(&#x27;a&#x27;)    // Create a note, A3
  .scale(&#x27;lydian&#x27;)  // Create a lydian scale with that note as root (A lydian)
  .interval(&#x27;M2&#x27;)   // Transpose the whole scale a major second up (B lydian)
  .<span class="apidocCodeKeywordSpan">get</span>(&#x27;third&#x27;)     // Get the third note of the scale (D#4)
  .chord(&#x27;maj9&#x27;)    // Create a maj9 chord with that note as root (D#maj9)
  .toString();      // Make a string representation: &#x27;D#maj9&#x27;
```

Documentation
------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.interval" id="apidoc.element.teoria.Scale.prototype.interval">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>interval
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (interval) {
  interval = (typeof interval === &#x27;string&#x27;) ?
    Interval.toCoord(interval) : interval;
  return new Scale(this.tonic.interval(interval), this.scale);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.<span class="apidocCodeKeywordSpan">interval</span>(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.notes" id="apidoc.element.teoria.Scale.prototype.notes">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>notes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notes = function () {
  var notes = [];

  for (var i = 0, length = this.scale.length; i &#x3c; length; i++) {
    notes.push(this.tonic.interval(this.scale[i]));
  }

  return notes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
that represents the current voicing of the chord.

Here&#x27;s an example:
```javascript
var bbmaj = teoria.chord(&#x27;Bbmaj7&#x27;);
// Default voicing:
bbmaj.voicing();  // #-&#x3e; [&#x27;P1&#x27;, &#x27;M3&#x27;, &#x27;P5&#x27;, &#x27;M7&#x27;];
bbmaj.<span class="apidocCodeKeywordSpan">notes</span>();    // #-&#x3e; [&#x27;bb&#x27;, &#x27;d&#x27;, &#x27;f&#x27;, &#x27;a&#
x27;];

// New voicing
bbmaj.voicing([&#x27;P1&#x27;, &#x27;P5&#x27;, &#x27;M7&#x27;, &#x27;M10&#x27;]);
bbmaj.notes();    // #-&#x3e; [&#x27;bb&#x27;, &#x27;f&#x27;, &#x27;a&#x27;, &#x27;d&#x27;];
```
*NB:* Note that above returned results are pseudo-results, as they will be
returned wrapped in `Interval` and `Note` objects.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.simple" id="apidoc.element.teoria.Scale.prototype.simple">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>simple
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simple = function () {
  return this.notes().map(function(n) { return n.toString(true); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).<span class="apidocCodeKeywordSpan">simple</span>();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#
x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object

// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.solfege" id="apidoc.element.teoria.Scale.prototype.solfege">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>solfege
        <span class="apidocSignatureSpan">(index, showOctaves)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solfege = function (index, showOctaves) {
  if (index)
    return this.get(index).solfege(this, showOctaves);

  return this.notes().map(function(n) {
    return n.solfege(this, showOctaves);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = isStepStr ? knowledge.stepNumber[i] : i;

  return this.tonic.interval(this.scale[i - 1]);
},

solfege: function(index, showOctaves) {
  if (index)
    return this.get(index).<span class="apidocCodeKeywordSpan">solfege</span>(this, showOctaves);

  return this.notes().map(function(n) {
    return n.solfege(this, showOctaves);
  });
},

interval: function(interval) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.transpose" id="apidoc.element.teoria.Scale.prototype.transpose">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>transpose
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (interval) {
  var scale = this.interval(interval);
  this.scale = scale.scale;
  this.tonic = scale.tonic;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

interval: function(interval) {
  return new Chord(this.root.interval(interval), this.symbol);
},

transpose: function(interval) {
  this.root.<span class="apidocCodeKeywordSpan">transpose</span>(interval);
  this.name = this.root.name().toUpperCase() +
              this.root.accidental() + this.symbol;

  return this;
},

toString: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.Scale.prototype.type" id="apidoc.element.teoria.Scale.prototype.type">
        function <span class="apidocSignatureSpan">teoria.Scale.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
  var length = this.scale.length - 2;
  if (length &#x3c; 8) {
    return [&#x27;di&#x27;, &#x27;tri&#x27;, &#x27;tetra&#x27;, &#x27;penta&#x27;, &#x27;hexa&#x27;, &#x27;hepta&#x27;, &#x27;octa&#x27;][length] +
      &#x27;tonic&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Interval.toString()
- Returns the *simpleInterval* representation of the interval. E.g. `&#x27;P5&#x27;`,
`&#x27;M3&#x27;`, `&#x27;A9&#x27;`, etc.

#### Interval.base()
- Returns the name of the simple interval (not compound)

#### Interval.<span class="apidocCodeKeywordSpan">type</span>()
- Returns the type of array, either `&#x27;perfect&#x27;` (1, 4, 5, 8) or `&#x27;minor&#x27;` (2, 3, 6, 7)

#### Interval.quality([verbose])
- The quality of the interval (`&#x27;dd&#x27;`, `&#x27;d&#x27;` `&#x27;m&#x27;`, `&#x27;P&#x27;`, `&#x27;M&#x27;`, `&#x27;A&#x27
;` or `&#x27;AA&#x27;`)

*verbose*  is set to a truish value, then long quality names are returned:
`&#x27;doubly diminished&#x27;`, `&#x27;diminished&#x27;`, `&#x27;minor&#x27;`, etc.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.interval" id="apidoc.module.teoria.interval">module teoria.interval</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.interval.interval" id="apidoc.element.teoria.interval.interval">
        function <span class="apidocSignatureSpan">teoria.</span>interval
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intervalConstructor(from, to) {
  // Construct a Interval object from string representation
  if (typeof from === &#x27;string&#x27;)
    return Interval.toCoord(from);

  if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
    return Interval.from(from, Interval.toCoord(to));

  if (to instanceof Interval &#x26;&#x26; from instanceof Note)
    return Interval.from(from, to);

  if (to instanceof Note &#x26;&#x26; from instanceof Note)
    return Interval.between(from, to);

  throw new Error(&#x27;Invalid parameters&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.<span class="apidocCodeKeywordSpan">interval</span>(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.interval.between" id="apidoc.element.teoria.interval.between">
        function <span class="apidocSignatureSpan">teoria.interval.</span>between
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">between = function (from, to) {
  return new Interval(vector.sub(to.coord, from.coord));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
    return Interval.from(from, Interval.toCoord(to));

  if (to instanceof Interval &#x26;&#x26; from instanceof Note)
    return Interval.from(from, to);

  if (to instanceof Note &#x26;&#x26; from instanceof Note)
    return Interval.<span class="apidocCodeKeywordSpan">between</span>(from, to);

  throw new Error(&#x27;Invalid parameters&#x27;);
}

intervalConstructor.toCoord = Interval.toCoord;
intervalConstructor.from = Interval.from;
intervalConstructor.between = Interval.between;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.interval.from" id="apidoc.element.teoria.interval.from">
        function <span class="apidocSignatureSpan">teoria.interval.</span>from
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (from, to) {
  return from.interval(to);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// never thought I would write this, but: Legacy support
function intervalConstructor(from, to) {
// Construct a Interval object from string representation
if (typeof from === &#x27;string&#x27;)
  return Interval.toCoord(from);

if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
  return Interval.<span class="apidocCodeKeywordSpan">from</span>(from, Interval.toCoord(to));

if (to instanceof Interval &#x26;&#x26; from instanceof Note)
  return Interval.from(from, to);

if (to instanceof Note &#x26;&#x26; from instanceof Note)
  return Interval.between(from, to);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.interval.invert" id="apidoc.element.teoria.interval.invert">
        function <span class="apidocSignatureSpan">teoria.interval.</span>invert
        <span class="apidocSignatureSpan">(sInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (sInterval) {
  return Interval.toCoord(sInterval).invert().toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var c3 = teoria.note.fromKey(28); // From a piano key number

// Find and create notes based on intervals
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).<span class="apidocCodeKeywordSpan">invert</span>(); // Returns a Interval representing
 a major seventh

// Create scales, based on notes.
a4.scale(&#x27;mixolydian&#x27;).simple();  // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c#&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f#&#x22;, &#x22;g&#x22;]
a4.scale(&#x27;aeolian&#x27;).simple();     // Returns: [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;, &#x22;e&#x22
;, &#x22;f&#x22;, &#x22;g&#x22;]
g5.scale(&#x27;ionian&#x27;).simple();      // Returns: [&#x22;g&#x22;, &#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22
;, &#x22;e&#x22;, &#x22;f#&#x22;]
g5.scale(&#x27;dorian&#x27;);               // Returns a Scale object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.interval.toCoord" id="apidoc.element.teoria.interval.toCoord">
        function <span class="apidocSignatureSpan">teoria.interval.</span>toCoord
        <span class="apidocSignatureSpan">(simple)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toCoord = function (simple) {
  var coord = toCoord(simple);
  if (!coord)
    throw new Error(&#x27;Invalid simple format interval&#x27;);

  return new Interval(coord);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var teoria;

// never thought I would write this, but: Legacy support
function intervalConstructor(from, to) {
// Construct a Interval object from string representation
if (typeof from === &#x27;string&#x27;)
  return Interval.<span class="apidocCodeKeywordSpan">toCoord</span>(from);

if (typeof to === &#x27;string&#x27; &#x26;&#x26; from instanceof Note)
  return Interval.from(from, Interval.toCoord(to));

if (to instanceof Interval &#x26;&#x26; from instanceof Note)
  return Interval.from(from, to);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.note" id="apidoc.module.teoria.note">module teoria.note</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.note.note" id="apidoc.element.teoria.note.note">
        function <span class="apidocSignatureSpan">teoria.</span>note
        <span class="apidocSignatureSpan">(name, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noteConstructor(name, duration) {
  if (typeof name === &#x27;string&#x27;)
    return Note.fromString(name, duration);
  else
    return new Note(name, duration);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (name instanceof Note)
  return new Chord(name, symbol);

throw new Error(&#x27;Invalid Chord. Couldn\&#x27;t find note name&#x27;);
}

function scaleConstructor(tonic, scale) {
tonic = (tonic instanceof Note) ? tonic : teoria.<span class="apidocCodeKeywordSpan">note</span>(tonic);
return new Scale(tonic, scale);
}

teoria = {
note: noteConstructor,

chord: chordConstructor,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.note.fromFrequency" id="apidoc.element.teoria.note.fromFrequency">
        function <span class="apidocSignatureSpan">teoria.note.</span>fromFrequency
        <span class="apidocSignatureSpan">(fq, concertPitch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromFrequency = function (fq, concertPitch) {
  var key, cents, originalFq;
  concertPitch = concertPitch || 440;

  key = 49 + 12 * ((Math.log(fq) - Math.log(concertPitch)) / Math.log(2));
  key = Math.round(key);
  originalFq = concertPitch * Math.pow(2, (key - 49) / 12);
  cents = 1200 * (Math.log(fq / originalFq) / Math.log(2));

  return { note: Note.fromKey(key), cents: cents };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Create chords with the powerful chord parser
a4.chord(&#x27;sus2&#x27;).name;    // Returns the name of the chord: &#x27;Asus2&#x27;
c3.chord(&#x27;m&#x27;).name;       // Returns &#x27;Cm&#x27;
teoria.chord(&#x27;Ab#5b9&#x27;);   // Returns a Chord object, representing a Ab#5b9 chord
g5.chord(&#x27;dim&#x27;);          // Returns a Chord object, representing a Gdim chord

// Calculate note frequencies or find the note corresponding to a frequency
teoria.note.<span class="apidocCodeKeywordSpan">fromFrequency</span>(467); // Returns: {&#x27;note&#x27;:{...},&#x27;cents&#x27;:
3.102831} -&#x3e; A4# a little out of tune.
a4.fq(); // Outputs 440
g5.fq(); // Outputs 783.9908719634985

// teoria allows for crazy chaining:
teoria.note(&#x27;a&#x27;)    // Create a note, A3
.scale(&#x27;lydian&#x27;)  // Create a lydian scale with that note as root (A lydian)
.interval(&#x27;M2&#x27;)   // Transpose the whole scale a major second up (B lydian)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.note.fromKey" id="apidoc.element.teoria.note.fromKey">
        function <span class="apidocSignatureSpan">teoria.note.</span>fromKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromKey = function (key) {
  var octave = Math.floor((key - 4) / 12);
  var distance = key - (octave * 12) - 4;
  var name = knowledge.fifths[(2 * Math.round(distance / 2) + 1) % 7];
  var subDiff = vector.sub(knowledge.notes[name], knowledge.A4);
  var note = vector.add(subDiff, [octave + 1, 0]);
  var diff = (key - 49) - vector.sum(vector.mul(note, [12, 7]));

  var arg = diff ? vector.add(note, vector.mul(knowledge.sharp, diff)) : note;
  return new Note(arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for a technical library reference, look further down this document.

```javascript

// Create notes:
var a4 = teoria.note(&#x27;a4&#x27;);       // Scientific notation
var g5 = teoria.note(&#x22;g&#x27;&#x27;&#x22;);      // Helmholtz notation
var c3 = teoria.note.<span class="apidocCodeKeywordSpan">fromKey</span>(28); // From a piano key number

// Find and create notes based on intervals
teoria.interval(a4, g5);    // Returns a Interval object representing a minor seventh
teoria.interval(a4, &#x27;M6&#x27;);  // Returns a Note representing F#5
a4.interval(&#x27;m3&#x27;);          // Returns a Note representing C#4
a4.interval(g5);            // Returns a Interval object representing a minor seventh
a4.interval(teoria.note(&#x27;bb5&#x27;)).invert(); // Returns a Interval representing a major seventh
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.note.fromMIDI" id="apidoc.element.teoria.note.fromMIDI">
        function <span class="apidocSignatureSpan">teoria.note.</span>fromMIDI
        <span class="apidocSignatureSpan">(note)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromMIDI = function (note) {
  return Note.fromKey(note - 20);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### teoria.note.fromFrequency(fq)
A static method returns an object containing two elements:

*note* - A `Note` which corresponds to the closest note with the given frequency

*cents* - A number value of how many cents the note is out of tune

### teoria.note.<span class="apidocCodeKeywordSpan">fromMIDI</span>(note)
- Returns an instance of Note set to the corresponding MIDI note value.

*note* - A number ranging from 0-127 representing a MIDI note value

### teoria.note.fromString(note)
- Returns an instance of Note representing the note name
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.note.fromString" id="apidoc.element.teoria.note.fromString">
        function <span class="apidocSignatureSpan">teoria.note.</span>fromString
        <span class="apidocSignatureSpan">(name, dur)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (name, dur) {
  var coord = scientific(name);
  if (!coord) coord = helmholtz(name);
  return new Note(coord, dur);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
intervalConstructor.toCoord = Interval.toCoord;
intervalConstructor.from = Interval.from;
intervalConstructor.between = Interval.between;
intervalConstructor.invert = Interval.invert;

function noteConstructor(name, duration) {
  if (typeof name === &#x27;string&#x27;)
    return Note.<span class="apidocCodeKeywordSpan">fromString</span>(name, duration);
  else
    return new Note(name, duration);
}

noteConstructor.fromString = Note.fromString;
noteConstructor.fromKey = Note.fromKey;
noteConstructor.fromFrequency = Note.fromFrequency;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.teoria.vector" id="apidoc.module.teoria.vector">module teoria.vector</a></h1>


    <h2>
        <a href="#apidoc.element.teoria.vector.add" id="apidoc.element.teoria.vector.add">
        function <span class="apidocSignatureSpan">teoria.vector.</span>add
        <span class="apidocSignatureSpan">(note, interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (note, interval) {
  return [note[0] + interval[0], note[1] + interval[1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.value() &#x3e;= 1 ? &#x27;up&#x27; : &#x27;down&#x27;;
},

simple: function(ignore) {
  // Get the (upwards) base interval (with quality)
  var simple = knowledge.intervals[this.base()];
  var toAdd = vector.mul(knowledge.sharp, this.qualityValue());
  simple = vector.<span class="apidocCodeKeywordSpan">add</span>(simple, toAdd);

  // Turn it around if necessary
  if (!ignore)
    simple = this.direction() === &#x27;down&#x27; ? vector.mul(simple, -1) : simple;

  return new Interval(simple);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.vector.mul" id="apidoc.element.teoria.vector.mul">
        function <span class="apidocSignatureSpan">teoria.vector.</span>mul
        <span class="apidocSignatureSpan">(note, interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function (note, interval) {
  if (typeof interval === &#x27;number&#x27;)
    return [note[0] * interval, note[1] * interval];
  else
    return [note[0] * interval[0], note[1] * interval[1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Interval.prototype = {
name: function() {
  return knowledge.intervalsIndex[this.number() - 1];
},

semitones: function() {
  return vector.sum(vector.<span class="apidocCodeKeywordSpan">mul</span>(this.coord, [12, 7]));
},

number: function() {
  return Math.abs(this.value());
},

value: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.vector.sub" id="apidoc.element.teoria.vector.sub">
        function <span class="apidocSignatureSpan">teoria.vector.</span>sub
        <span class="apidocSignatureSpan">(note, interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function (note, interval) {
  return [note[0] - interval[0], note[1] - interval[1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
number: function() {
  return Math.abs(this.value());
},

value: function() {
  var toMultiply = Math.floor((this.coord[1] - 2) / 7) + 1;
  var product = vector.mul(knowledge.sharp, toMultiply);
  var without = vector.<span class="apidocCodeKeywordSpan">sub</span>(this.coord, product);
  var i = knowledge.intervalFromFifth[without[1] + 5];
  var diff = without[0] - knowledge.intervals[i][0];
  var val = knowledge.stepNumber[i] + diff * 7;

  return (val &#x3e; 0) ? val : val - 2;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.teoria.vector.sum" id="apidoc.element.teoria.vector.sum">
        function <span class="apidocSignatureSpan">teoria.vector.</span>sum
        <span class="apidocSignatureSpan">(coord)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function (coord) {
  return coord[0] + coord[1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Interval.prototype = {
name: function() {
  return knowledge.intervalsIndex[this.number() - 1];
},

semitones: function() {
  return vector.<span class="apidocCodeKeywordSpan">sum</span>(vector.mul(this.coord, [12, 7]));
},

number: function() {
  return Math.abs(this.value());
},

value: function() {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
